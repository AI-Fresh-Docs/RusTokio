# План реализации пересборки модулей (с учетом текущей архитектуры)

Этот документ — практический план внедрения **WordPress/NodeBB‑стиля** для
модулей RusToK, где **install/uninstall = изменение манифеста → rebuild →
deploy**. План учитывает текущую архитектуру: модульный реестр формируется на
старте сервера, модули — Rust‑crates, а приложение уже содержит админ‑интерфейсы
(`apps/admin`, `apps/next-admin`).

## 0) Текущие реалии (от чего отталкиваемся)

- **Модули компилируются в бинарник**, а `ModuleRegistry` строится при старте
  сервера. Это означает, что установка “нового” модуля без сборки невозможна —
  требуется новый артефакт сборки.
- **Включение/выключение** модуля на tenant‑уровне уже решено через
  `tenant_modules` и `toggle_module` (runtime‑логика), но это не меняет набор
  модулей в бинарнике.
- Уже есть документация по **манифесту** и **admin rebuild blueprint** —
  это основа для формализации процесса пересборки и API‑интеграций.

## 1) Цели внедрения (что должно работать)

1. **Install/uninstall через админку**: админ изменяет список модулей,
   запускает сборку, видит статус и может откатиться.
2. **Источник правды** — `modules.toml` (или иной manifest), зафиксированный
   в репозитории/артефакте сборки.
3. **Сборка и деплой** происходят автоматически и воспроизводимо.
4. **Никакой runtime‑подгрузки нативного кода**, только пересборка.

## 2) Предлагаемая дорожная карта

### Этап A — Формализовать манифест и связать его с кодом

**Цель:** чтобы набор модулей *фактически* определялся манифестом.

Задачи:
1. **Выбрать файл манифеста** (например, `modules.toml`) и утвердить схему
   на уровне команды (ссылаться на спецификацию).
2. **Автоматизировать сборку реестра**:
   - добавить `xtask`/`build.rs`/скрипт, который генерирует код регистрации
     модулей на основе манифеста (например, `apps/server/src/modules/generated.rs`).
   - `build_registry()` импортирует сгенерированный список вместо
     “ручной” регистрации.
3. **Проверка на этапе CI**: если манифест изменился, а сгенерированный код
   не обновлён — билд должен падать.

Результат: **манифест становится единственным источником набора модулей.**

### Этап B — Минимальный Build‑Service (без админки)

**Цель:** дать команде способ запускать rebuild без UI, но с логами и статусом.

Задачи:
1. **Сервис‑обёртка** (отдельный сервис или job runner), который:
   - принимает `modules.toml` (или ссылку на git‑коммит),
   - запускает сборку,
   - публикует артефакт/образ,
   - сохраняет статус/логи.
2. **Минимальная модель данных** (таблица `builds` или внешнее хранилище):
   - `build_id`, `status`, `manifest_hash`, `started_at`, `finished_at`,
     `logs_url`, `release_id`.
3. **CLI/HTTP API** для запуска и статуса (достаточно пары эндпойнтов,
   как в blueprint).

Результат: **сборку можно запускать вручную/скриптом**, не дожидаясь UI.

### Этап C — Интеграция с админкой (NodeBB‑подобный UX)

**Цель:** UI‑кнопка “Install/Uninstall” с прогрессом сборки и деплоя.

Задачи:
1. **Admin API** (в `apps/server`) для:
   - создания rebuild‑задачи,
   - чтения статуса,
   - запуска deploy/rollback.
2. **UI в админке** (`apps/admin` или `apps/next-admin`):
   - управление списком модулей (manifest),
   - модальное окно статуса сборки,
   - история сборок/релизов.
3. **RBAC**: только админы/суперадмины могут запускать rebuild.

Результат: **полный “NodeBB‑подобный” опыт** — управляемые пересборки из UI.

### Этап D — Надёжность и контроль качества

**Цель:** сделать процесс безопасным для продакшна.

Задачи:
1. **Smoke‑checks** после деплоя:
   - health‑endpoint,
   - список модулей,
   - проверка миграций.
2. **Rollback** по `release_id` (политика хранения N релизов).
3. **Аудит‑лог** изменений манифеста (кто, когда, зачем).

Результат: **управляемый и безопасный цикл релизов**.

## 3) Детальные артефакты (что нужно создать)

- `modules.toml` (или аналог) — манифест.
- Генератор реестра (скрипт/xtask).
- Build‑service (job runner + хранение статусов).
- Админ‑API и UI.
- Документация для ops (pipeline + rollback).

## 4) Риски и способы смягчения

- **Долгая сборка** → показывать прогресс и статус, хранить логи.
- **Неудачная сборка** → не деплоить автоматически, требовать ручного деплоя.
- **Сломанный модуль** → проверка совместимости/версий в manifest lint.

## 5) Предлагаемая последовательность внедрения (минимальный MVP)

1. Манифест + генерация реестра (этап A).
2. Минимальный Build‑Service + CLI (этап B).
3. Админка + RBAC (этап C).
4. Rollback + мониторинг (этап D).

---

Если нужно, следующий шаг — разложить эти этапы в задачи по репозиторию
(`apps/server`, `apps/admin`, `docs`, `CI`) и оценить трудозатраты.
